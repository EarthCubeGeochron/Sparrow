"""
Sparrow's task manager provides a way to run long-running processes
(e.g., imports), within the context of a Sparrow application.

Tasks have

- Unique names
- Autogenerated command-line applications (if desired)
- Celery task representation
- Optional stdout redirection

"""
import celery
from celery import Task, Celery, current_app
from sparrow.logs import get_logger
from sparrow.plugins import SparrowCorePlugin
from click import decorators, echo
from sparrow.context import get_plugin
import typer

log = get_logger(__name__)

celery = Celery("tasks", broker="redis://broker//")


class SparrowTaskError(Exception):
    ...


_tasks_to_register = {}


class SparrowTaskManager(SparrowCorePlugin):
    name = "task-manager"
    celery: Celery

    _cli_app = typer.Typer()
    _task_commands = []
    _tasks = {}

    def __init__(self, app):
        self.celery = celery
        super().__init__(app)

    def register_task(self, func, *args, **kwargs):
        # Get plugin name
        name = kwargs.get("name", func.__name__)
        destructive = kwargs.get("destructive", False)
        cli_only = kwargs.get("cli_only", False)
        if destructive:
            cli_only = True
        # Apply decorators

        # # Copy docstring and annotations to task
        # _func.__doc__ = func.__doc__
        # _func.__annotations__ = func.__annotations__

        # mgr = app.plugins.get("task-manager")
        self._cli_app.command(name=name)(func)
        if not cli_only:
            self.celery.task(*args, **kwargs)(func)

        self._task_commands.append(name)
        log.debug(f"Registering task {name}")

        # typer_click_object = typer.main.get_command(cli_app)
        # if plugin is not None:
        #     typer_click_object._plugin = plugin.name

        # from sparrow.cli import cli

        # cli.add_command(typer_click_object, name)

        func._is_sparrow_task = True
        self._tasks[name] = func
        return func

    def get_task(self, name):
        return self._tasks[name]

    def on_plugins_initialized(self):
        global _tasks_to_register
        for k, v in _tasks_to_register.items():
            (func, args, kwargs) = v
            kwargs["name"] = k
            self.register_task(func, *args, **kwargs)
        _tasks_to_register = {}

    def on_setup_cli(self, cli):
        self._cli_app._add_completion = False
        typer_click_object = typer.main.get_command(self._cli_app)
        cli.add_command(typer_click_object, "tasks")


class SparrowTask(Task):
    def __call__(self, *args, **kwargs):
        """In celery task this function calls the run method, here you can
        set some environment variable before the run of the task"""
        return self.run(*args, **kwargs)

    def after_return(self, status, retval, task_id, args, kwargs, einfo):
        # exit point of the task whatever is the state
        pass


log = get_logger(__name__)

cli_app = typer.Typer()
_typer_commands = []


def sparrow_task(*args, **kwargs):
    """A decorator to define a sparrow task."""
    kwargs.setdefault("base", SparrowTask)

    def wrapper(func):
        task_name = kwargs.get("name", func.__name__)
        try:
            mgr = get_plugin("task-manager")
            mgr.register_task(func, *args, **kwargs)
        except (ImportError, AttributeError, ValueError):
            _tasks_to_register[task_name] = (func, args, kwargs)

        def _run_task(*args, **kwargs):
            mgr = get_plugin("task-manager")
            func = mgr.get_task(task_name)
            return func(*args, **kwargs)

        return _run_task

    return wrapper


@sparrow_task(name="hello")
def hello_task(name: str):
    """Say hello!"""
    echo(f"Hello {name}")
